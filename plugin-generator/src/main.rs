// Copyright (c) 2016, Mikkel Kroman <mk@uplink.io>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#![feature(question_mark)]

use std::fs::{self, File};
use std::io::{self, Write};
use std::path::Path;

extern crate toml;
extern crate semver;

mod plugin;
mod error;

use plugin::Plugin;
use error::Error;

const ZETA_IMPL: &'static str = include_str!("../resources/zeta_impl.rs.tmpl");

fn main() {
    if let Err(ref err) = main_maybe_error() {
        panic!("{}", err);
    }
}

fn main_maybe_error() -> Result<(), Error> {
    let manifest_path = std::env::var_os("CARGO_MANIFEST_DIR")
        .expect("CARGO_MANIFEST_DIR is not defined");
    let out_dir = std::env::var_os("OUT_DIR")
        .expect("OUT_DIR is not defined");
    let project_path = Path::new(&manifest_path);
    let plugins_path = project_path.join("plugins");
    let plugins_out_dir = Path::new(&out_dir).join("plugins");
    let mut plugins: Vec<Plugin> = Vec::new();

    if plugins_path.is_dir() {
        fs::create_dir_all(&plugins_out_dir)?;

        for entry in plugins_path.read_dir()? {
            let entry = entry?;

            if entry.path().is_dir() {
                let plugin_source_path = entry.path();
                let plugin = Plugin::from_dir(&plugin_source_path)?;
                let plugin_build_dir = &plugins_out_dir.join(&plugin.name);

                println!("Generating shim for plugin `{}`\n", plugin.name);

                // Create the plugin build dir if in case it doesn't exist.
                fs::create_dir_all(&plugin_build_dir)?;

                // Create the crate structure for the plugin.
                create_plugin_crate(&plugin, &plugin_build_dir)?;

                // Now copy all the source files over.
                copy_plugin_source_files(&plugin, &plugins_out_dir.parent().unwrap())?;

                plugins.push(plugin);
            }
        }
    }

    let plugins_build_dir = project_path.join("target").join("plugins");

    // Create the `plugins` crate that zeta will use.
    fs::create_dir_all(&plugins_build_dir.join("src"))?;

    let mut f = fs::File::create(plugins_build_dir.join("Cargo.toml"))?;

    write!(f, "# THIS IS AUTOMATICALLY GENERATED BY `plugin-generator` - DO NOT EDIT!\n\
        [package]\n\
        name = \"plugins\"\n\
        version = \"0.1.0\"\n\
        \n\
        [lib]\n\
        \n\
        [dependencies]\n\
        zeta-runtime = {{ path = \"{}\" }}\n", &project_path.join("..").join("..").join("zeta-runtime").display())?;

    for plugin in &plugins {
        write!(f, "zplugin-{} = {{ version = \"{}\", path = \"{}\" }}\n",
            plugin.name, plugin.version, plugin.source_path.as_path().display())?;
    }

    create_lib_src(&plugins, &plugins_build_dir.join("src"))?;

    Ok(())
}

fn create_lib_src(plugins: &Vec<Plugin>, source_dir: &Path) -> Result<(), Error> {
    let mut file = File::create(source_dir.join("lib.rs")).unwrap();

    write!(file, "// THIS IS AUTOMATICALLY GENERATED BY `plugin-generator` - DO NOT EDIT!\n\n\
        extern crate zeta_runtime;\n")?;

    for plugin in plugins {
        let undercase_plugin_name = plugin.name.replace("-", "_");

        write!(file, "extern crate zplugin_{} as {};\n", &undercase_plugin_name,
            &undercase_plugin_name)?;
    }

    // write!(file, "\n// Import the modules.\n");

    // for plugin in plugins {
    //     let undercase_plugin_name = plugin.name.replace("-", "_");
    //     write!(file, "mod {};\n", &undercase_plugin_name);
    // }

    write!(file, "\npub fn register(mut manager: &mut zeta_runtime::PluginManager) {{\n")?;

    for plugin in plugins {
        let undercase_plugin_name = plugin.name.replace("-", "_");
        write!(file, "    {}::register(&mut manager);\n", &undercase_plugin_name);
    }

    write!(file, "}}\n");

    Ok(())
}

/// Creates the crate structure for the given `plugin`.
fn create_plugin_crate(plugin: &Plugin, plugin_build_dir: &Path) -> Result<(), Error> {
    use toml::Value;

    // What a nightmare it is working with the toml crate.
    let name = Value::String(format!("zplugin-{}", &plugin.name));
    let version = Value::String(plugin.version.clone());
    let authors = Value::Array(plugin.authors.iter()
        .map(|s| Value::String(s.to_owned())).collect());
    let mut package = toml::Table::new();

    package.insert("name".to_owned(), name);
    package.insert("authors".to_owned(), authors);
    package.insert("version".to_owned(), version);

    let mut root = toml::Table::new();

    root.insert("dependencies".to_owned(), Value::Table(plugin.dependencies.clone()));
    root.insert("package".to_owned(), Value::Table(package));

    let mut file = File::create(&plugin_build_dir.join("Cargo.toml"))?;

    write!(file, "# THIS IS AUTOMATICALLY GENERATED BY `plugin-generator` - DO NOT EDIT!\n{}\n",
        toml::encode_str(&root))?;

    let manifest_dir = std::env::var_os("CARGO_MANIFEST_DIR").unwrap();
    let current_dir = std::env::current_dir().unwrap();

    write!(file, "[dependencies.zeta-runtime]\n\
        path = \"{}\"\n", 
        &current_dir.as_path().join(&manifest_dir).join("zeta-runtime").display())?;

    Ok(())
}

/// Copy the source files for the plugin.
fn copy_plugin_source_files(plugin: &Plugin, destination_dir: &Path) -> Result<(), Error> {
    let source_path = plugin.source_path.as_path();

    if source_path.is_dir() {
        recursive_file_copy(&plugin, &source_path, &destination_dir)?;
    }

    Ok(())
}

fn recursive_file_copy(plugin: &Plugin, source_path: &Path, destination_dir: &Path)
    -> Result<(), Error> {
    for entry in source_path.read_dir()? {
        let path = entry?.path();
        let destination_path = destination_dir.join(&path);

        if path.is_dir() {
            create_dir(&destination_path).unwrap();
            recursive_file_copy(&plugin, &path, &destination_dir).unwrap();
        } else if path.is_file() {
            if path.file_name().unwrap() == "Plugin.toml" {
                continue;
            }

            println!("{} -> {}", path.as_path().display(), destination_path.display());
            fs::copy(&path, &destination_path).unwrap();
        }
    }

    Ok(())
}

fn create_dir<P: AsRef<Path>>(path: P) -> Result<(), Error> {
    match fs::create_dir(path.as_ref()) {
        Ok(()) => Ok(()),
        Err(error) => {
            if error.kind() == io::ErrorKind::AlreadyExists {
                Ok(())
            } else {
                Err(error.into())
            }
        }
    }
}